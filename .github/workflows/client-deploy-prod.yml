# File: .github/workflows/client-deploy-prod.yml

# --- REPLACE START: production deploy workflow (main â†’ production env) ---
name: Client Deploy (prod)

on:
  push:
    branches:
      - main
  # Manual trigger is handy during setup/debug
  workflow_dispatch:

# Least-privilege permissions + OIDC readiness
permissions:
  id-token: write
  contents: read

jobs:
  build-deploy:
    name: Build client, deploy to S3, invalidate CloudFront (prod)
    runs-on: ubuntu-latest
    environment: production

    # Keep client as default working directory for run-steps,
    # so paths like "dist" resolve without extra prefixes.
    defaults:
      run:
        working-directory: client

    env:
      # Prefer repository variable if set; otherwise use eu-north-1 as a safe default
      AWS_REGION: ${{ vars.AWS_REGION != '' && vars.AWS_REGION || 'eu-north-1' }}

    steps:
      # -------------------------------------------------------------
      # Checkout
      # -------------------------------------------------------------
      - name: Checkout
        uses: actions/checkout@v4

      # -------------------------------------------------------------
      # Node
      # -------------------------------------------------------------
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          # The replacement region is marked between // --- REPLACE START and // --- REPLACE END so you can verify exactly what changed
          # --- REPLACE START (keep cache disabled to avoid cache path issues) ---
          # cache: npm
          # cache-dependency-path: client/package-lock.json
          # --- REPLACE END ---

      # -------------------------------------------------------------
      # Install dependencies (root, monorepo workspaces)
      # -------------------------------------------------------------
      - name: Install dependencies
        working-directory: .
        shell: bash
        run: |
          # --- REPLACE START: fix YAML issues + ensure optional deps are allowed (native binaries) ---
          set -euo pipefail

          echo "== Install dependencies (root) =="
          echo "Node: $(node --version)"
          echo "npm:  $(npm --version)"
          echo "PWD:  $(pwd)"

          # Ensure optional deps are not omitted (native/platform binaries can come via optionalDependencies)
          export npm_config_optional=true
          export npm_config_omit=""

          npm ci
          # --- REPLACE END ---

      # -------------------------------------------------------------
      # Repair: lightningcss native binary (Linux runner)
      # -------------------------------------------------------------
      - name: Repair lightningcss native binary (Linux)
        working-directory: .
        shell: bash
        run: |
          # --- REPLACE START: robust lightningcss fix (no YAML heredocs, no invalid indentation) ---
          set -euo pipefail

          echo "== lightningcss sanity check =="
          echo "Node: $(node --version)"
          echo "npm:  $(npm --version)"
          echo "PWD:  $(pwd)"

          if [[ ! -f "node_modules/lightningcss/package.json" ]]; then
            echo "::error::node_modules/lightningcss is missing. Install step likely failed."
            exit 1
          fi

          LC_VERSION="$(node -p "require('./node_modules/lightningcss/package.json').version")"
          echo "lightningcss version: ${LC_VERSION}"

          # Pick platform optional dependency (name@version) from lightningcss' optionalDependencies.
          # Avoids guessing package names and avoids YAML-breaking heredocs.
          CANDIDATE="$(node -e 'try{const pkg=require("./node_modules/lightningcss/package.json");const opt=pkg.optionalDependencies||{};const keys=Object.keys(opt);const p=process.platform;const a=process.arch;const pick=keys.find(k=>k.includes(p)&&k.includes(a)&&k.includes("gnu"))||keys.find(k=>k.includes(p)&&k.includes(a))||"";process.stdout.write(pick?`${pick}@${opt[pick]}`:"");}catch(e){process.stdout.write("");}')"

          if [[ -n "${CANDIDATE}" ]]; then
            CANDIDATE_NAME="${CANDIDATE%%@*}"
          else
            # Fallback for GitHub ubuntu-latest (x64 glibc)
            CANDIDATE="lightningcss-linux-x64-gnu"
            CANDIDATE_NAME="${CANDIDATE}"
          fi

          SUFFIX="${CANDIDATE_NAME#lightningcss-}"
          EXPECTED="node_modules/lightningcss/lightningcss.${SUFFIX}.node"

          echo "Platform package candidate: ${CANDIDATE}"
          echo "Expected binary path: ${EXPECTED}"

          if [[ -f "${EXPECTED}" ]]; then
            echo "OK: Found lightningcss native binary."
            exit 0
          fi

          echo "::warning::Missing lightningcss native binary. Attempting repair..."

          echo "Installing platform package (no-save): ${CANDIDATE}"
          npm install --no-save "${CANDIDATE}" --no-audit --no-fund || true

          echo "Rebuilding lightningcss (safe even if purely prebuilt)..."
          npm rebuild lightningcss --verbose || true

          # If postinstall didn't place the binary, try to locate any lightningcss.*.node and copy into lightningcss folder.
          if [[ ! -f "${EXPECTED}" ]]; then
            echo "::warning::Binary still missing. Searching for lightningcss.*.node under node_modules..."
            FOUND="$(find node_modules -maxdepth 4 -type f -name 'lightningcss.*.node' 2>/dev/null | head -n 1 || true)"
            if [[ -n "${FOUND}" ]]; then
              echo "Found binary at: ${FOUND}"
              mkdir -p "node_modules/lightningcss"
              cp -f "${FOUND}" "node_modules/lightningcss/$(basename "${FOUND}")" || true
            else
              echo "::warning::No lightningcss.*.node found under node_modules."
            fi
          fi

          echo "== lightningcss directory listing =="
          ls -la node_modules/lightningcss || true
          echo "== lightningcss/node directory listing =="
          ls -la node_modules/lightningcss/node || true

          if [[ ! -f "${EXPECTED}" ]]; then
            echo "::error::lightningcss native binary is still missing after repair attempts: ${EXPECTED}"
            exit 1
          fi

          echo "OK: Repaired lightningcss native binary: ${EXPECTED}"
          # --- REPLACE END ---

      # -------------------------------------------------------------
      # Build (pass production Environment secrets to Vite + sitemap)
      # -------------------------------------------------------------
      - name: Build
        env:
          CLIENT_URL: ${{ secrets.CLIENT_URL }}
          VITE_API_BASE_URL: ${{ secrets.VITE_API_BASE_URL }}
        run: npm run build

      # -------------------------------------------------------------
      # AWS credentials via OIDC (no static keys)
      # -------------------------------------------------------------
      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}
          audience: sts.amazonaws.com

      # -------------------------------------------------------------
      # Resolve S3 bucket for production
      # -------------------------------------------------------------
      - name: Resolve S3 bucket (prod)
        id: bucket
        shell: bash
        env:
          S3_BUCKET_PROD_VAR: ${{ vars.S3_BUCKET_PROD }}
          S3_BUCKET_PROD_SECRET: ${{ secrets.S3_BUCKET_PROD }}
        run: |
          if [[ -n "$S3_BUCKET_PROD_VAR" ]]; then
            echo "value=$S3_BUCKET_PROD_VAR" >> "$GITHUB_OUTPUT"
          else
            echo "value=$S3_BUCKET_PROD_SECRET" >> "$GITHUB_OUTPUT"
          fi
          echo "Selected bucket: $(cat $GITHUB_OUTPUT | cut -d= -f2- | tail -n1)"

      # -------------------------------------------------------------
      # Upload to S3
      # -------------------------------------------------------------
      - name: Upload to S3
        shell: bash
        run: |
          BUCKET="${{ steps.bucket.outputs.value }}"
          if [[ -z "$BUCKET" ]]; then
            echo "::error::S3 bucket not resolved (check repository Variables/Secrets: S3_BUCKET_PROD)."
            exit 1
          fi
          echo "Syncing client/dist to s3://${BUCKET}"
          aws s3 sync dist "s3://${BUCKET}" --delete

      # -------------------------------------------------------------
      # Resolve CloudFront distribution
      # -------------------------------------------------------------
      - name: Resolve CloudFront distribution (prod)
        id: cf
        shell: bash
        run: |
          if [[ -n "${{ vars.CF_DISTRIBUTION_ID_PROD }}" ]]; then
            echo "id=${{ vars.CF_DISTRIBUTION_ID_PROD }}" >> "$GITHUB_OUTPUT"
          else
            echo "id=${{ secrets.CLOUDFRONT_DISTRIBUTION_ID_PROD }}" >> "$GITHUB_OUTPUT"
          fi
          echo "Selected distribution: $(cat $GITHUB_OUTPUT | cut -d= -f2- | tail -n1)"

      # -------------------------------------------------------------
      # Invalidate CloudFront
      # -------------------------------------------------------------
      - name: Invalidate CloudFront
        shell: bash
        run: |
          DIST_ID="${{ steps.cf.outputs.id }}"
          if [[ -z "$DIST_ID" ]]; then
            echo "::error::CloudFront Distribution ID not resolved (vars/Secrets: CF_DISTRIBUTION_ID_PROD)."
            exit 1
          fi
          echo "Creating CloudFront invalidation for distribution ${DIST_ID}"
          aws cloudfront create-invalidation --distribution-id "${DIST_ID}" --paths "/*"

      # -------------------------------------------------------------
      # Summary
      # -------------------------------------------------------------
      - name: Deployment summary
        shell: bash
        run: |
          echo "Branch: ${GITHUB_REF_NAME}"
          echo "Region: ${AWS_REGION}"
          echo "S3 bucket: ${{ steps.bucket.outputs.value }}"
          echo "CloudFront: ${{ steps.cf.outputs.id }}"
# --- REPLACE END ---

