// PATH: server/routes/auth.js
// @ts-nocheck

// --- REPLACE START: unified auth routes (ESM, merged old + new, fixed imports + debug) ---
import express from "express";
import jwt from "jsonwebtoken";
import cookieParser from "cookie-parser";
import crypto from "crypto";
import bcrypt from "bcryptjs";
import dotenv from "dotenv";

// NOTE: Align imports to the current project layout (routes/ outside src/)
// Keep functionality identical; only fix paths and keep all routes RELATIVE.
import User from "../src/models/User.js";
import sendEmail from "../src/utils/sendEmail.js";
import authenticate from "../../src/middleware/authenticate.js";
import { validateRegister, validateLogin } from "../middleware/validators/auth.js";
import { sanitizeAndValidateProfile } from "../../middleware/profileValidator.js";
import upload from "../../middleware/upload.js";
import { cookieOptions } from "../src/utils/cookieOptions.js";

// Services for modern auth flow
import {
  loginUserService,
  refreshService,
  meService,
  registerUserService,
} from "../src/controllers/services/auth.service.js";

dotenv.config();

const router = express.Router();

// Middleware to parse JSON, URL-encoded bodies, and cookies
router.use(express.json());
router.use(express.urlencoded({ extended: true }));
router.use(cookieParser());

// Centralized refresh cookie options
const refreshCookieOptions = {
  httpOnly: true,
  secure: process.env.NODE_ENV === "production",
  sameSite: "strict",
  // NOTE: keep absolute path because router is mounted at /api/auth
  path: "/api/auth/refresh",
  maxAge:
    (parseInt(process.env.REFRESH_TOKEN_MAX_AGE_DAYS, 10) || 30) *
    24 *
    60 *
    60 *
    1000,
};

/**
 * Register / Login / Refresh / Me (via auth.service.js)
 * IMPORTANT: Routes are RELATIVE (no /api/auth prefix here).
 */
router.post("/register", validateRegister, async (req, res) => {
  try {
    return await registerUserService(req, res);
  } catch (err) {
    console.error("Register route error:", err);
    return res.status(500).json({ error: "Registration failed" });
  }
});

router.post("/login", validateLogin, async (req, res) => {
  try {
    return await loginUserService(req, res, { refreshCookieOptions });
  } catch (err) {
    console.error("Login route error:", err);
    return res.status(500).json({ error: "Login failed" });
  }
});

router.post("/refresh", async (req, res) => {
  try {
    return await refreshService(req, res, { refreshCookieOptions });
  } catch (err) {
    console.error("Refresh route error:", err);
    return res.status(500).json({ error: "Token refresh failed" });
  }
});

router.get("/me", async (req, res) => {
  try {
    return await meService(req, res);
  } catch (err) {
    console.error("Me route error:", err);
    return res.status(500).json({ error: "Could not fetch user" });
  }
});

/**
 * Logout
 */
router.post("/logout", (req, res) => {
  try {
    res.clearCookie("refreshToken", cookieOptions);
    return res.json({ message: "Logout successful" });
  } catch (err) {
    console.error("Logout error:", err);
    return res.status(500).json({ error: "Logout failed" });
  }
});

/**
 * Forgot Password
 */
router.post("/forgot-password", async (req, res) => {
  const { email } = req.body;
  if (!email) {
    return res.status(400).json({ error: "Email is required" });
  }
  try {
    const user = await User.findOne({ email });
    if (!user) {
      // Do not reveal existence of account
      return res.json({
        message: "If that email is registered, a reset link has been sent",
      });
    }
    const resetToken = crypto.randomBytes(32).toString("hex");
    user.passwordResetToken = crypto
      .createHash("sha256")
      .update(resetToken)
      .digest("hex");
    user.passwordResetExpires = Date.now() + 3600000; // 1 hour
    await user.save();

    const resetURL = `${process.env.CLIENT_URL}/reset-password?token=${resetToken}&id=${user._id}`;
    const message =
      "You requested a password reset. Click the link below to set a new password:\n\n" +
      resetURL +
      "\n\nIf you did not request this, ignore this email.";
    await sendEmail(user.email, "Password Reset Request", message);

    return res.json({
      message: "If that email is registered, a reset link has been sent",
    });
  } catch (err) {
    console.error("Forgot password error:", err);
    return res.status(500).json({ error: "Failed to process forgot password" });
  }
});

/**
 * Reset Password
 */
router.post("/reset-password", async (req, res) => {
  const { id, token, newPassword } = req.body;
  if (!id || !token || !newPassword) {
    return res.status(400).json({ error: "Missing required fields" });
  }
  try {
    const hashedToken = crypto.createHash("sha256").update(token).digest("hex");
    const user = await User.findOne({
      _id: id,
      passwordResetToken: hashedToken,
      passwordResetExpires: { $gt: Date.now() },
    });
    if (!user) {
      return res.status(400).json({ error: "Invalid or expired reset token" });
    }
    user.password = await bcrypt.hash(newPassword, 10);
    user.passwordResetToken = undefined;
    user.passwordResetExpires = undefined;
    await user.save();
    return res.json({ message: "Password has been reset successfully" });
  } catch (err) {
    console.error("Reset password error:", err);
    return res.status(500).json({ error: "Failed to reset password" });
  }
});

/**
 * Update User Profile
 * NOTE: Keep behavior intact; only relative path.
 */
router.put(
  "/profile",
  authenticate,
  sanitizeAndValidateProfile,
  upload.fields([
    { name: "image", maxCount: 1 },
    { name: "extraImages", maxCount: 6 },
  ]),
  async (req, res) => {
    try {
      const updateData = {};

      // Coordinates
      if (req.body.latitude !== undefined) {
        const lat = parseFloat(req.body.latitude);
        if (!isNaN(lat)) updateData.latitude = lat;
      }
      if (req.body.longitude !== undefined) {
        const lng = parseFloat(req.body.longitude);
        if (!isNaN(lng)) updateData.longitude = lng;
      }

      // Location object
      if (req.body.location) {
        const loc = req.body.location;
        if (loc.country) updateData.country = loc.country;
        if (loc.region) updateData.region = loc.region;
        if (loc.city) updateData.city = loc.city;
      }

      // Basic fields
      const fields = [
        "name",
        "email",
        "age",
        "height",
        "weight",
        "status",
        "religion",
        "children",
        "pets",
        "summary",
        "goal",
        "lookingFor",
        "bodyType",
        "weightUnit",
        "profession",
        "professionCategory",
      ];
      fields.forEach((field) => {
        if (req.body[field] !== undefined) updateData[field] = req.body[field];
      });

      // Files
      if (req.files && req.files.image) {
        updateData.profilePicture = `uploads/${req.files.image[0].filename}`;
      }
      if (req.files && req.files.extraImages) {
        updateData.extraImages = req.files.extraImages.map(
          (f) => `uploads/${f.filename}`
        );
      }

      const updated = await User.findByIdAndUpdate(req.user.userId, updateData, {
        new: true,
      }).select("-password");

      return res.json(updated);
    } catch (err) {
      console.error("Profile update error:", err);
      return res.status(500).json({ error: "Profile update failed" });
    }
  }
);

/**
 * Delete User Account
 */
router.delete("/delete", authenticate, async (req, res) => {
  try {
    await User.findByIdAndDelete(req.user.userId);
    return res.json({ message: "Account deleted successfully" });
  } catch (err) {
    console.error("Account deletion error:", err);
    return res.status(500).json({ error: "Account deletion failed" });
  }
});

// Debug: list all registered auth routes at module load
console.log(
  "âœ… Auth routes active:",
  router.stack.map((r) => r.route?.path).filter(Boolean)
);

// Default export of the Router instance (CRITICAL for proper mount)
export default router;
// --- REPLACE END ---
















