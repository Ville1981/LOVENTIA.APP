// PATH: server/index.cjs

// --- REPLACE START: dynamic-import bridge (remove local /api/auth mount; keep diagnostics and other shims intact) ---
"use strict";

/**
 * CommonJS bridge that dynamically imports the ESM Express app.
 * - Keeps "type": "module" setups intact.
 * - Importing this file evaluates ./src/app.js (which should create and export the Express `app`).
 * - Exports a Promise that resolves to the Express `app` instance (default/app/app.default).
 *
 * IMPORTANT:
 *  ‚Ä¢ Do NOT mount /api/auth here (it is mounted in src/app.js to guarantee correct ordering).
 *  ‚Ä¢ Keep diagnostics: console dump + GET /__routes + GET /__routes_full.
 *  ‚Ä¢ Optional shims for other feature routers (users, discover) remain supported.
 */

const fs = require("fs");
const path = require("path");
const { pathToFileURL } = require("url");

// Resolve the ESM app and choose the most likely export carrying the Express `app`.
const appPromise = import("./src/app.js").then((m) => m.default || m.app || m);
module.exports = appPromise;

/* --------------------------------- Helpers -------------------------------- */

/** Resolve first existing path from candidates (keeps original behavior). */
function resolveExistingFile(candidates) {
  for (const p of candidates) {
    try {
      if (fs.existsSync(p)) return p;
    } catch {
      // ignore fs errors
    }
  }
  return null;
}

/** Load a router exported via CJS or ESM. Returns a Router function or null. */
async function loadRouter(filePath) {
  if (!filePath) return null;
  if (filePath.endsWith(".cjs")) {
    const mod = require(filePath);
    return mod?.default || mod?.router || mod || null;
  } else {
    const mod = await import(pathToFileURL(filePath).href);
    return mod?.default || mod?.router || mod || null;
  }
}

/**
 * Extract a human-readable mount prefix from an Express layer's RegExp.
 * This is best-effort but sufficient to show meaningful base paths.
 */
function extractMountFromLayer(layer) {
  try {
    if (layer?.regexp?.fast_slash) return "/";
    if (layer?.regexp?.fast_star) return "*";
    const src = layer?.regexp?.toString() || "";
    // Capture literal segment between slashes (e.g. /^\/api\/auth\/?/ -> "api")
    const m = src.match(/\\\/([^\\^$?()[\]+*{}|]+)\\\//);
    if (m && m[1]) return `/${m[1]}`;
    return "";
  } catch {
    return "";
  }
}

/**
 * Recursively walk an Express stack and collect FULL paths including base mounts.
 * Output format: "METHODS /base/path".
 */
function collectFullPaths(appOrRouter) {
  const out = [];
  const walk = (stack, prefix = "") => {
    if (!Array.isArray(stack)) return;

    for (const layer of stack) {
      // Terminal route layer
      if (layer?.route?.path) {
        const methods = Object.keys(layer.route.methods || {})
          .filter(Boolean)
          .map((m) => m.toUpperCase())
          .join(",");
        out.push(`${methods} ${prefix}${layer.route.path}`);
        continue;
      }
      // Nested router
      if (layer?.name === "router" && layer?.handle?.stack) {
        const mount = extractMountFromLayer(layer);
        walk(layer.handle.stack, `${prefix}${mount}`);
      }
    }
  };
  const stack = appOrRouter?._router?.stack || appOrRouter?.stack;
  if (stack) walk(stack, "");
  return out;
}

/* ------------------------------- Shim Mounts ------------------------------- */

/**
 * After the ESM app is loaded, mount shims if present.
 * NOTE: /api/auth is intentionally NOT mounted here ‚Äî it is mounted inside src/app.js.
 */
appPromise.then(async (app) => {
  if (!app || typeof app.use !== "function") {
    console.error("‚ùå App did not resolve to an Express instance from ./src/app.js");
    return;
  }

  // USERS shim
  try {
    const usersPath = resolveExistingFile([
      path.resolve(__dirname, "./routes/user.js"),
      path.resolve(__dirname, "./routes/user.cjs"),
      path.resolve(__dirname, "./src/routes/user.js"),
      path.resolve(__dirname, "./src/routes/user.cjs"),
    ]);
    if (usersPath) {
      const usersRouter = await loadRouter(usersPath);
      if (typeof usersRouter === "function") {
        app.use("/api/users", usersRouter);
        console.log("‚úÖ Mounted /api/users via shim:", usersPath);
      } else {
        console.warn("‚ö†Ô∏è Users shim exported a non-router value. File:", usersPath, "Type:", typeof usersRouter);
      }
    } else {
      console.warn("‚ö†Ô∏è Users shim not found (./routes|./src/routes user.{js,cjs})");
    }
  } catch (e) {
    console.warn("‚ö†Ô∏è Could not mount /api/users:", e?.message || e);
  }

  // DISCOVER shim
  try {
    const discoverPath = resolveExistingFile([
      path.resolve(__dirname, "./routes/discover.js"),
      path.resolve(__dirname, "./routes/discover.cjs"),
      path.resolve(__dirname, "./src/routes/discover.js"),
      path.resolve(__dirname, "./src/routes/discover.cjs"),
    ]);
    if (discoverPath) {
      const discoverRouter = await loadRouter(discoverPath);
      if (typeof discoverRouter === "function") {
        app.use("/api/discover", discoverRouter);
        console.log("‚úÖ Mounted /api/discover via shim:", discoverPath);
      } else {
        console.warn("‚ö†Ô∏è Discover shim exported a non-router value. File:", discoverPath, "Type:", typeof discoverRouter);
      }
    } else {
      console.warn("‚ö†Ô∏è Discover shim not found (./routes|./src/routes discover.{js,cjs})");
    }
  } catch (e) {
    console.warn("‚ö†Ô∏è Could not mount /api/discover:", e?.message || e);
  }

  // AUTH shim ‚Äî SKIPPED on purpose (auth is mounted in src/app.js)
  try {
    const authPath = resolveExistingFile([
      path.resolve(__dirname, "./routes/auth.js"),
      path.resolve(__dirname, "./src/routes/auth.js"),
      path.resolve(__dirname, "./routes/auth.cjs"),
      path.resolve(__dirname, "./src/routes/auth.cjs"),
    ]);

    if (authPath) {
      // Load for validation/logging only; do not mount here to avoid duplicates.
      const ns = await import(pathToFileURL(authPath).href);
      const exported = ns?.default ?? ns?.router ?? ns ?? null;
      const exportedType = typeof exported;

      if (exportedType !== "function") {
        const keys = ns ? Object.keys(ns) : [];
        console.warn("‚ö†Ô∏è Auth shim export is not a Router function.", {
          file: authPath,
          exportedType,
          exportedKeys: keys,
          hint:
            "Ensure server/routes/auth.js does `export default router;` and uses relative paths only.",
        });
      } else {
        console.log(
          "‚ÑπÔ∏è Detected auth router at",
          authPath,
          "‚Äî not mounting here because /api/auth is mounted in src/app.js (correct order)."
        );
      }

      // ‚ö†Ô∏è DO NOT MOUNT AUTH HERE:
      // app.use("/api/auth", exported); // ‚Üê intentionally disabled to prevent duplicates
    } else {
      console.warn("‚ÑπÔ∏è Auth shim not present (this is fine since src/app.js mounts /api/auth).");
    }
  } catch (e) {
    console.warn("‚ö†Ô∏è Skipped auth shim validation due to error:", e?.message || e);
  }

  /* --------------------------- Diagnostics endpoints --------------------------- */

  // Console dump with full mount prefixes
  try {
    const listed = collectFullPaths(app);
    console.log("üîé All mounted routes (full paths):", listed);
  } catch (e) {
    console.warn("‚ö†Ô∏è Could not list routes to console:", e?.message || e);
  }

  // Provide GET /__routes with FULL paths (avoid double-register if already present).
  try {
    const already = (collectFullPaths(app) || []).some((r) => r.endsWith(" /__routes"));
    if (!already) {
      app.get("/__routes", (_req, res) => {
        try {
          res.json(collectFullPaths(app));
        } catch (err) {
          res.status(500).json({ error: err?.message || String(err) });
        }
      });
      console.log("üß≠ Registered /__routes diagnostics endpoint (full-path walker).");
    }
  } catch (e) {
    console.warn("‚ö†Ô∏è Could not register /__routes diagnostics endpoint:", e?.message || e);
  }

  // Provide an unconditional GET /__routes_full (never skipped), useful if /__routes existed earlier.
  try {
    app.get("/__routes_full", (_req, res) => {
      try {
        res.json(collectFullPaths(app));
      } catch (err) {
        res.status(500).json({ error: err?.message || String(err) });
      }
    });
    console.log("üß≠ Registered /__routes_full diagnostics endpoint (full-path walker).");
  } catch (e) {
    console.warn("‚ö†Ô∏è Could not register /__routes_full:", e?.message || e);
  }

  // NOTE: Keep 404 handler inside src/app.js AFTER all mounts. Do not add another here.
});
// --- REPLACE END ---
