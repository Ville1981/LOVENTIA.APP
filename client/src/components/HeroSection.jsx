// PATH: client/src/components/HeroSection.jsx

// --- REPLACE START: prevent hero1..4 from being fetched on mobile by disabling slideshow + rendering only the LCP hero image on small viewports ---
import React, { useEffect, useMemo, useState } from "react";
import { useTranslation } from "react-i18next";
import "./HeroSection.css";

/**
 * NOTE ABOUT IMAGES
 * ---------------
 * We keep the existing image list and the slide CSS.
 * Rotation cadence stays at 5s (same as before).
 *
 * PERFORMANCE NOTE (IMPORTANT)
 * ---------------------------
 * Lighthouse runs showed hero1..hero4 being fetched immediately (multi-MB),
 * which caused huge transfer size on initial navigation.
 *
 * Fix (small & safe):
 * - On MOBILE viewports (<768px): do NOT render the slideshow images at all.
 *   We render ONLY the first (LCP) hero image via <picture>.
 * - On DESKTOP viewports (>=768px): keep slideshow behavior, but render placeholders
 *   for non-active slides to prevent fetching all hero images on initial load.
 *   We then preload only the NEXT slide in the background for smooth transitions.
 *
 * This aligns with the existing Navbar/Footer "desktop-only backgroundImage" gating.
 */
const images = ["/hero.jpg", "/hero1.jpg", "/hero2.jpg", "/hero3.jpg", "/hero4.jpg"];

/**
 * Responsive hero variants generated by scripts/optimize-hero.mjs
 * Keep these as simple constants to avoid accidental runtime differences.
 */
const HERO_SIZES = "(max-width: 640px) 100vw, (max-width: 1024px) 90vw, 1100px";
const HERO_SRCSET_AVIF = [
  "/hero-480.avif 480w",
  "/hero-768.avif 768w",
  "/hero-1024.avif 1024w",
  "/hero-1280.avif 1280w",
  "/hero-1536.avif 1536w",
  "/hero-1920.avif 1920w",
].join(", ");
const HERO_SRCSET_WEBP = [
  "/hero-480.webp 480w",
  "/hero-768.webp 768w",
  "/hero-1024.webp 1024w",
  "/hero-1280.webp 1280w",
  "/hero-1536.webp 1536w",
  "/hero-1920.webp 1920w",
].join(", ");
const HERO_SRCSET_JPG = [
  "/hero-480.jpg 480w",
  "/hero-768.jpg 768w",
  "/hero-1024.jpg 1024w",
  "/hero-1280.jpg 1280w",
  "/hero-1536.jpg 1536w",
  "/hero-1920.jpg 1920w",
].join(", ");

// Metadata reported by the optimizer for the source hero asset (useful for CLS stability)
const HERO_WIDTH = 1024;
const HERO_HEIGHT = 1024;

// 1x1 transparent placeholder to prevent network fetches for non-active slides.
const TRANSPARENT_PLACEHOLDER =
  "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==";

function HeroSection() {
  const [currentImageIndex, setCurrentImageIndex] = useState(0);
  const [currentTextIndex, setCurrentTextIndex] = useState(0);

  // IMPORTANT: include both namespaces so we can safely fall back to existing legacy keys
  // (e.g., common.title/subtitle and/or translation.heroOtsikko) when heroText* keys are missing.
  const { t, i18n } = useTranslation(["common", "translation"]);

  /**
   * Desktop-only slideshow toggle
   * ----------------------------
   * On mobile, we keep the hero static and render ONLY the first image.
   * This prevents fetching hero1..hero4 on mobile (major perf win).
   */
  const [isDesktop, setIsDesktop] = useState(false);

  // --- REPLACE START: disable hero fade on first paint to avoid LCP delay ---
  /**
   * LCP NOTE (IMPORTANT)
   * --------------------
   * The CSS uses an opacity transition for slideshow fades. That can delay LCP because the
   * hero image is "fully visible" only after the transition finishes.
   *
   * Fix: disable transitions ONLY for the first paint, then enable them immediately after.
   * This preserves the desktop slideshow look while improving mobile LCP significantly.
   */
  const [enableFade, setEnableFade] = useState(false);

  useEffect(() => {
    if (typeof window === "undefined" || typeof window.requestAnimationFrame !== "function") {
      setEnableFade(true);
      return undefined;
    }

    const raf = window.requestAnimationFrame(() => setEnableFade(true));
    return () => window.cancelAnimationFrame(raf);
  }, []);
  // --- REPLACE END ---

  useEffect(() => {
    // Guard for non-browser/test environments
    if (typeof window === "undefined" || typeof window.matchMedia !== "function") return;

    // Tailwind md breakpoint is 768px by default; align with that for consistency.
    const mq = window.matchMedia("(min-width: 768px)");

    const apply = () => setIsDesktop(Boolean(mq.matches));
    apply();

    // Support both modern and legacy MediaQueryList APIs
    if (typeof mq.addEventListener === "function") {
      mq.addEventListener("change", apply);
      return () => mq.removeEventListener("change", apply);
    }

    // eslint-disable-next-line deprecations/deprecations
    mq.addListener(apply);
    // eslint-disable-next-line deprecations/deprecations
    return () => mq.removeListener(apply);
  }, []);

  /**
   * If we switch to mobile, pin the IMAGE index to 0 so we never rotate into other images.
   * Text is allowed to rotate safely without fetching additional images.
   */
  useEffect(() => {
    if (!isDesktop) {
      setCurrentImageIndex(0);
    }
  }, [isDesktop]);

  /**
   * (Historical context, kept to preserve file shape/length and avoid regressions)
   * We previously experimented with language buckets and alternative copy sets.
   * Keeping the arrays below harms nothing and can be re-used later if we need
   * to branch per-locale. These DO NOT affect the current timer/text logic.
   */
  const latinLangs = ["es-ES", "es-MX", "es-AR", "es-CO"];
  const modernLangs = ["it", "pl", "sw"];
  const useModernText =
    modernLangs.includes(i18n.language) ||
    (!latinLangs.includes(i18n.language) && i18n.language !== "en");

  // --- REPLACE START: fix hero text not updating by preferring translation:home.texts.* with safe fallbacks ---
  /**
   * ROOT CAUSE
   * ----------
   * - Many locales store the translated hero copy under: translation:home.texts[0..2]
   * - The HeroSection overlay can fall back incorrectly if it relies on missing keys.
   *
   * Fix:
   * - Prefer translation:home.texts.0..2 when present.
   * - Then fallback to translation:hero.0..2.
   * - Then fallback to translation:etusivu.heroTekstit.0..2 (older nested structure).
   * - Then fallback to common:title + common:subtitle.
   * - Then last resort English defaults.
   */
  const hasHomeTextsKeys =
    (typeof i18n.exists === "function" &&
      (i18n.exists("translation:home.texts.0") ||
        i18n.exists("translation:home.texts.1") ||
        i18n.exists("translation:home.texts.2"))) ||
    false;

  const hasHeroObjectKeys =
    (typeof i18n.exists === "function" &&
      (i18n.exists("translation:hero.0") ||
        i18n.exists("translation:hero.1") ||
        i18n.exists("translation:hero.2"))) ||
    false;

  const hasEtusivuArrayKeys =
    (typeof i18n.exists === "function" &&
      (i18n.exists("translation:etusivu.heroTekstit.0") ||
        i18n.exists("translation:etusivu.heroTekstit.1") ||
        i18n.exists("translation:etusivu.heroTekstit.2"))) ||
    false;

  const hasModernHeroKeys =
    (typeof i18n.exists === "function" &&
      (i18n.exists("common:heroTextModern1") ||
        i18n.exists("common:heroTextModern2") ||
        i18n.exists("common:heroTextModern3"))) ||
    false;

  const hasClassicHeroKeys =
    (typeof i18n.exists === "function" &&
      (i18n.exists("common:heroText1") ||
        i18n.exists("common:heroText2") ||
        i18n.exists("common:heroText3"))) ||
    false;

  const hasHomeCommonKeys =
    (typeof i18n.exists === "function" && (i18n.exists("common:title") || i18n.exists("common:subtitle"))) || false;

  const hasLegacyTranslationHeroTitle =
    (typeof i18n.exists === "function" &&
      (i18n.exists("translation:heroOtsikko") ||
        i18n.exists("translation:tervetuloa") ||
        i18n.exists("translation:heroTeksti"))) ||
    false;

  const heroText = useMemo(() => {
    const safeString = (value) => {
      const s = String(value ?? "");
      return s.trim();
    };

    const filterNonEmpty = (arr) => arr.map(safeString).filter(Boolean);

    if (hasHomeTextsKeys) {
      const t0 = safeString(t("translation:home.texts.0", { defaultValue: "" }));
      const t1 = safeString(t("translation:home.texts.1", { defaultValue: "" }));
      const t2 = safeString(t("translation:home.texts.2", { defaultValue: "" }));
      const lines = filterNonEmpty([t0, t1, t2]);
      if (lines.length) return lines;
    }

    if (hasHeroObjectKeys) {
      const h0 = safeString(t("translation:hero.0", { defaultValue: "" }));
      const h1 = safeString(t("translation:hero.1", { defaultValue: "" }));
      const h2 = safeString(t("translation:hero.2", { defaultValue: "" }));
      const lines = filterNonEmpty([h0, h1, h2]);
      if (lines.length) return lines;
    }

    if (hasEtusivuArrayKeys) {
      const e0 = safeString(t("translation:etusivu.heroTekstit.0", { defaultValue: "" }));
      const e1 = safeString(t("translation:etusivu.heroTekstit.1", { defaultValue: "" }));
      const e2 = safeString(t("translation:etusivu.heroTekstit.2", { defaultValue: "" }));
      const lines = filterNonEmpty([e0, e1, e2]);
      if (lines.length) return lines;
    }

    if (useModernText && hasModernHeroKeys) {
      return filterNonEmpty([
        t("common:heroTextModern1", { defaultValue: "Find meaningful connections." }),
        t("common:heroTextModern2", { defaultValue: "Chat, match, and build something real." }),
        t("common:heroTextModern3", { defaultValue: "Your next great story starts here." }),
      ]);
    }

    if (hasClassicHeroKeys) {
      return filterNonEmpty([
        t("common:heroText1", { defaultValue: "Find love and meaningful connections." }),
        t("common:heroText2", { defaultValue: "Meet new people and start chatting today." }),
        t("common:heroText3", { defaultValue: "Discover your perfect match." }),
      ]);
    }

    if (hasHomeCommonKeys) {
      const title = safeString(t("common:title", { defaultValue: "Welcome to Loventia.site!" }));
      const subtitle = safeString(t("common:subtitle", { defaultValue: "Find meaningful connections." }));
      const lines = filterNonEmpty([title, subtitle]);
      if (lines.length) return lines;
    }

    if (hasLegacyTranslationHeroTitle) {
      const title =
        safeString(t("translation:heroOtsikko", { defaultValue: "" })) ||
        safeString(t("translation:tervetuloa", { defaultValue: "" })) ||
        safeString(t("translation:home.title", { defaultValue: "" }));
      const subtitle =
        safeString(t("translation:heroTeksti", { defaultValue: "" })) ||
        safeString(t("translation:home.subtitle", { defaultValue: "" })) ||
        safeString(t("common:subtitle", { defaultValue: "Find meaningful connections." }));
      const lines = filterNonEmpty([title || "Welcome to Loventia.site!", subtitle]);
      if (lines.length) return lines;
    }

    return ["Find love that lasts.", "Meet people who share your values.", "Your next match is one click away."];
  }, [
    t,
    i18n.language,
    useModernText,
    hasHomeTextsKeys,
    hasHeroObjectKeys,
    hasEtusivuArrayKeys,
    hasModernHeroKeys,
    hasClassicHeroKeys,
    hasHomeCommonKeys,
    hasLegacyTranslationHeroTitle,
  ]);
  // --- REPLACE END ---

  const heroLines = heroText;

  useEffect(() => {
    const interval = setInterval(() => {
      // Desktop: rotate both image and text
      if (isDesktop) {
        setCurrentImageIndex((prev) => (prev === images.length - 1 ? 0 : prev + 1));
      } else {
        // Mobile safety: never rotate into hero1..hero4
        setCurrentImageIndex(0);
      }

      // Text can rotate safely on both mobile and desktop
      setCurrentTextIndex((prev) => (prev === heroLines.length - 1 ? 0 : prev + 1));
    }, 5000);

    return () => clearInterval(interval);
  }, [heroLines.length, i18n.language, isDesktop]);

  /**
   * When the user changes language mid-rotation, keep the same text index if possible.
   * If the target language has fewer lines (shouldn't happen, but safe), clamp the index.
   */
  useEffect(() => {
    setCurrentTextIndex((idx) => (idx >= heroLines.length ? 0 : idx));
  }, [heroLines.length]);

  // Ensure compatibility with tests/runtimes where i18n.dir might be missing
  const dir = typeof i18n?.dir === "function" ? i18n.dir() : "ltr";

  // Use a generic localized alt; always a string (never an object)
  const altText = String(t("common:heroImageAlt", { defaultValue: "Hero image" }));

  // --- REPLACE START: class helper to keep slideshow look but avoid first-paint fade ---
  const baseSlideClass = (isActive) =>
    `hero-slide ${isActive ? "active" : ""} ${enableFade ? "" : "no-fade"}`.trim();
  // --- REPLACE END ---

  // --- REPLACE START: prevent fetching all desktop slides by rendering placeholders + preloading only next slide ---
  /**
   * DESKTOP IMAGE HYGIENE (IMPORTANT)
   * --------------------------------
   * - Rendering <img src="/hero1.jpg"> for ALL slides triggers eager downloads.
   * - Instead, render a transparent placeholder for non-active slides.
   * - Preload ONLY the NEXT slide in the background so transitions remain smooth.
   *
   * This reduces initial desktop transfer dramatically while preserving slideshow behavior.
   */
  useEffect(() => {
    if (!isDesktop) return;

    const nextIndex = currentImageIndex === images.length - 1 ? 0 : currentImageIndex + 1;

    // Do not "warm" all slides; only the next one.
    const nextUrl = images[nextIndex];

    // Skip if next is the optimized LCP hero (index 0); it is already handled via <picture>.
    if (nextIndex === 0) return;

    let cancelled = false;
    let idleId = null;
    let timeoutId = null;

    const preload = () => {
      if (cancelled) return;
      try {
        const img = new Image();
        img.decoding = "async";
        img.src = nextUrl;
      } catch {
        // Preload is best-effort; ignore failures.
      }
    };

    if (typeof window !== "undefined" && typeof window.requestIdleCallback === "function") {
      idleId = window.requestIdleCallback(preload, { timeout: 1500 });
    } else {
      timeoutId = window.setTimeout(preload, 800);
    }

    return () => {
      cancelled = true;
      if (typeof window !== "undefined" && typeof window.cancelIdleCallback === "function" && idleId != null) {
        window.cancelIdleCallback(idleId);
      }
      if (timeoutId != null) {
        window.clearTimeout(timeoutId);
      }
    };
  }, [currentImageIndex, isDesktop]);
  // --- REPLACE END ---

  return (
    <div className="hero-section-container">
      <div className="hero-section">
        {/* MOBILE: render ONLY the first (LCP) hero image so hero1..hero4 are never fetched */}
        {!isDesktop && (
          <picture>
            <source type="image/avif" srcSet={HERO_SRCSET_AVIF} sizes={HERO_SIZES} />
            <source type="image/webp" srcSet={HERO_SRCSET_WEBP} sizes={HERO_SIZES} />
            <img
              src="/hero-1024.jpg"
              srcSet={HERO_SRCSET_JPG}
              sizes={HERO_SIZES}
              alt={altText}
              className={baseSlideClass(true)}
              loading="eager"
              decoding="async"
              fetchpriority="high"
              width={HERO_WIDTH}
              height={HERO_HEIGHT}
            />
          </picture>
        )}

        {/* DESKTOP: slideshow behavior preserved, but only the ACTIVE slide gets a real src */}
        {isDesktop &&
          images.map((img, index) => {
            const isActive = index === currentImageIndex;

            // Keep CSS class names exactly as before to avoid regressions.
            // We only add "no-fade" on first paint to avoid LCP delay.
            const className = baseSlideClass(isActive);

            // Slide #0 (LCP): only render responsive <picture> when active.
            // When not active, render a transparent placeholder so it does NOT fetch.
            if (index === 0) {
              if (!isActive) {
                return (
                  <img
                    key={index}
                    src={TRANSPARENT_PLACEHOLDER}
                    alt={altText}
                    className={className}
                    decoding="async"
                    width={HERO_WIDTH}
                    height={HERO_HEIGHT}
                    data-src={img}
                  />
                );
              }

              return (
                <picture key={index}>
                  <source type="image/avif" srcSet={HERO_SRCSET_AVIF} sizes={HERO_SIZES} />
                  <source type="image/webp" srcSet={HERO_SRCSET_WEBP} sizes={HERO_SIZES} />
                  <img
                    src="/hero-1024.jpg"
                    srcSet={HERO_SRCSET_JPG}
                    sizes={HERO_SIZES}
                    alt={altText}
                    className={className}
                    loading="eager"
                    decoding="async"
                    fetchpriority="high"
                    width={HERO_WIDTH}
                    height={HERO_HEIGHT}
                  />
                </picture>
              );
            }

            // Other slides: only active slide gets real src, others are placeholders.
            return (
              <img
                key={index}
                src={isActive ? img : TRANSPARENT_PLACEHOLDER}
                alt={altText}
                className={className}
                decoding="async"
                loading={isActive ? "eager" : "lazy"}
                fetchpriority={isActive ? "low" : "low"}
                data-src={img}
              />
            );
          })}

        {/* Text overlay â€” respects RTL languages */}
        <div className={`hero-overlay ${dir === "rtl" ? "rtl-align" : "left"}`}>
          <h1 dir={dir}>{heroLines[currentTextIndex] || ""}</h1>
        </div>
      </div>
    </div>
  );
}

export default HeroSection;
// --- REPLACE END ---

